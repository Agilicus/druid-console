// Generated by CoffeeScript 1.7.1
var Exception, async, debug, defaultDataExtractor, makeManagerForPath, zookeeper,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

async = require('async');

zookeeper = require('node-zookeeper-client');

Exception = zookeeper.Exception;

debug = false;

defaultDataExtractor = function(data) {
  var e;
  try {
    data = JSON.parse(data);
  } catch (_error) {
    e = _error;
    return null;
  }
  if (!(data.address && data.port)) {
    return null;
  }
  return {
    host: data.address,
    port: data.port
  };
};

makeManagerForPath = function(client, path, dataExtractor, locatorTimeout) {
  var dispatch, next, onChange, onGetChildren, pool, processQueue, queue;
  next = -1;
  pool = null;
  queue = [];
  onGetChildren = function(err, children) {
    if (err) {
      if (debug) {
        console.log('Failed to list children of %s due to: %s.', path, err);
      }
      pool = [];
      processQueue();
      return;
    }
    if (debug) {
      console.log('Children of %s are: %j.', path, children);
    }
    async.map(children, function(child, callback) {
      return client.getData(path + '/' + child, function(err, data) {
        if (err) {
          if (err.getCode() === Exception.NO_NODE) {
            callback(null, null);
          } else {
            if (debug) {
              console.log(err.stack);
            }
            callback(null, null);
          }
          return;
        }
        callback(null, dataExtractor(data.toString('utf8')));
      });
    }, function(err, newPool) {
      pool = newPool.filter(Boolean);
      processQueue();
    });
  };
  onChange = function(event) {
    if (debug) {
      console.log('Got watcher event: %s', event);
    }
    client.getChildren(path, onChange, onGetChildren);
  };
  client.getChildren(path, onChange, onGetChildren);
  dispatch = function(callback) {
    if (!pool) {
      throw new Error('get next called on loading pool');
    }
    if (pool.length) {
      next++;
      return callback(null, pool[next % pool.length]);
    } else {
      return callback(new Error('empty pool'));
    }
  };
  processQueue = function() {
    while (queue.length) {
      dispatch(queue.shift());
    }
  };
  return function(callback) {
    if (pool) {
      dispatch(callback);
      return;
    }
    queue.push(callback);
    if (locatorTimeout) {
      setTimeout((function() {
        if (__indexOf.call(queue, callback) < 0) {
          return;
        }
        queue = queue.filter(function(c) {
          return c !== callback;
        });
        return callback(new Error('timeout'));
      }), locatorTimeout);
    }
  };
};

module.exports = function(_arg) {
  var active, client, dataExtractor, locatorTimeout, pathManager, retries, servers, sessionTimeout, spinDelay;
  servers = _arg.servers, dataExtractor = _arg.dataExtractor, locatorTimeout = _arg.locatorTimeout, sessionTimeout = _arg.sessionTimeout, spinDelay = _arg.spinDelay, retries = _arg.retries;
  dataExtractor || (dataExtractor = defaultDataExtractor);
  locatorTimeout || (locatorTimeout = 2000);
  client = zookeeper.createClient(servers, {
    sessionTimeout: sessionTimeout,
    spinDelay: spinDelay,
    retries: retries
  });
  active = false;
  pathManager = {};
  return function(path) {
    if (typeof path !== 'string') {
      throw new TypeError('path must be a string');
    }
    if (path[0] !== '/') {
      path = '/' + path;
    }
    if (!active) {
      client.on('connected', function() {
        if (debug) {
          console.log('Connected to ZooKeeper.');
        }
      });
      client.on('disconnected', function() {
        if (debug) {
          console.log('Dosconnected from ZooKeeper.');
        }
      });
      client.connect();
      active = true;
    }
    pathManager[path] || (pathManager[path] = makeManagerForPath(client, path, dataExtractor, locatorTimeout));
    return pathManager[path];
  };
};
